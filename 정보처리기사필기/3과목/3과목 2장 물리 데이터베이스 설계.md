정보처리기사 핵심 개념 정리
===========================

3과목 데이터베이스 구축
---------------------------

### 2장 물리 데이터베이스 설계
#### SECTION 085 사전 조사 분석
* 물리 데이터베이스 설계
  * 논리적 구조로 표현된 논리적 데이터베이스를 디스크 등의 물리적 저장장치에 저장할 수 있는 물리적 구조의 데이터로 변환하느 과정 
  * 기본적이 데이터 단위는 저장 레코드(Stored Record)
  * 꼭 포함되어야 할 것은 저장 레코드의 양식 설계, 레코드 집중의 분석 및 설계, 접근 경로 설계 등 
  * 여러 가지 타입의 저장 레코드 집합
  * 데이터베이스 시스템의 성능에 중대한 영향을 미침
  * 설계 시 고려 사항
    * 인덱스 구조 
    * 레코드 크기 
    * 파일에 조내하는 레코드 개수 
    * 파일에 대한 트랜잭션의 갱신과 참조 성향 
    * 성능 향상을 위한 개념 스키마의 변경 여부 검토
    * 번번한 질의와 트랜잭션들의 수행속도를 높이기 위한 고려
    * 시스템 운용 시 파일의 크기의 변화 가능성

* 데이터 명명 규칙 파악
  * 물리 데이터 모델에 적용해야 하는 규칙으로, 조직마다 다를 수 있으므로 물리 데이터 모델의 설계 전에 파악(ex: 업무코드, 리소스 그룹, 거래코드)
  * 데이터 표준화 및 논리 데이터베이스 설계의 결과물 등을 통해 파악
  * 물리 & 논리 데이터베이스 설계에 일관성을 유지
  * 중복 구축 등을 방지할 수 있음 
  * 논리 -> 물리 전환시 동일 명칭 부여의 근거로 사용 
  * 도메인, 데이터 사전에 대한 지식 필요
    * 도메인 : 객체에 포함된 속성들의 데이터 타입, 크기 등을 표준화 규칙에 따라 일관성 있게 정의한 것 
    * 데이터 사전 : 일관성 있는 데이터 이름과 인터페이스를 제공하기 위해 데이터 속성의 논리명, 물리명, 용어 정의를 기술해 놓은 것
    * 프로젝트에서 사용하는 명칭 부여의 근거로 사용

* 시스템 자원 파악
  * 데이터베이스 설치에 영향을 미칠 수 있는 물리적인 요소
  * 하드웨어 자원, 운영체제 및 DBMS 버전, DBMS 팡라미터 정보 등으로 구분 
  * DBMS의 저장 공간, 메모리 등에 대한 파라미터, 쿼리에서 활용하는 옵티마이저(Optimizer)의 사용 방법 등을 파악

* 데이터베이스 관리 요소 파악
  * 데이터베이스 운영과 관련된 관리 요소로, 데이터베이스 시스템의 환경에 따라 달라질 수 있으므로 미리 파악해야 함
  * 이를 기반으로 데이터베이스 시스템 조사 분석서를 작성 
  * 시스템 조사 분석서를 기반으로 데이터베이스 구조, 이중화 구성, 분산 데이터베이스, 접근제어/접근통제, DB암호화 등의 범위와 특성을 파악 

<br> 

#### SECTION 086 데이터베이스 저장 공간 설계 
* 테이블
  * 데이터베이스의 가장 기본적인 객체로 로우와 컬럼으로 구성 
  * 모든 데이터는 테이블에 저장 
  * 논리 설계 단계의 개체에 대응하는 객체
  * DBMS 종류에 따라 테이블의 명칭과 기능 등은 약간씩 차이가 있음 
  * 종류 : 일반, 클러스터 인덱스, 파티셔닝, 외부, 임시 

* 일반 테이블 
  * 테이블에 저장되는 데이터의 로우 위치는 속성값에 강관없이 데이터가 저장되는 순서에따라 결정됨 

* 클러스터드 인덱스 테이블 
  * 기본키나 인덱스키의 순서에 따라 데이터가 저장되는 테이블 
  * 일반적인 인덱스를 사용하는 테이블에 비해 접근 경로가 단축 

* 파티셔닝 테이블
  * 대용량의 테이블을 작은 논리적 단위인 파티션으로 나눈 테이블 
  * 대용량의 데이터를 효과적으로 관리할 수 있지만 파티션 키를 잘못 구성하면 성능 저하 등의 역효과를 초래 
  * 범위 분할, 해시 분할, 조합 분할(Composite partitioning) 등으로 나뉨 

* 외부 테이블(External Table)
  * 데이터베이스에서 일반 테이블처럼 이용할 수 있는 외부 파일로, 데이터베이스 내에 객체로 존재
  * 데이터웨어하우스(조직이나 기업체의 중심이 되는 주요 업무 시스템에서 추출되어 새롭게 생성된 데이터베이스로서, 의사 결정 지원 시스템을 지원하는 주체적 통합적, 시간적 데이터의 집합체)에서 ETL(Extraction, Transformation, Loaing ;데이터웨어하우스를 사용하여 추출(Extrct), 변환(Transform), 적재(Load)하는 일련의 모든 과정을 의미) 등의 작업에 유용하게 사용

* 임시 테이블(Temporary Table)
  * 트랜잭션이나 세션별로 데이터를 저장하고 처리할 수 있는 테이블
  * 트랜잭션이 종료되면 삭제 
  * 절차적인 처리를 위해 임시로 사용되는 테이블 

* 컬럼 
  * 테이블의 열을 구성하는 요소로 데이터 타입, 길이 등으로 정의
  * 데이터의 일관성 유지를 위해 사용되는 가장 기본적인 것으로, 도메인을 정의한 경우 도메인에 따라 데이터의 타입과 길이가 정의
  * 두 컬럼을 비교하는 연산에서 두 컬럼의 데이터 타입이나 길이가 다르면 DBMS 내부적으로 데이터 타입을 변환 후 비교 연산을 수행 
  * 참조 관계인 컬럼들은 데이터 타입과 길이가 일치해야 함 
  * 데이터 타입에 따른 컬럼의 물리적인 순서 
    * 고정 길이 컬럼이고 NOT Null : 앞
    * 가변 길이 컬럼 : 뒤 
    * Null 값이 많을 것으로 예상되는 컬럼 : 뒤

* 테이블스페이스(Tablespace) 
  * 데이블이 저장되는 논리적인 영역. 하나의 테이블스페이스에 하나 또는 그 이상의 테이블을 저장 
  * 테이블을 저장하면 논리적으로는 테이블스페이스에 저장되고, 물리적으로는 해당 테이블스페이스와 연관된 데이터 파일에 저장
  * 테이터베이스를 테이블, 테이블스페이스, 데이터 파일로 나눠 관리시 논리적 구성이 물리적 구성에 종속되지 않아 투명성이 보장 
  * 고려사항 
    * 업무별로 구분하여 지정 
    * 대용량 테이블, LOB(Large Object;대용량의 데이터를 저장할 수 있는 데이터 타입)타입의 데이터는 하나의 테이블스페이스에 독립적으로 저장 
    * 테이블과 인덱스는 분리 

<br>

#### SECTION 087 트랜잭션 분석 / CRUD 분석 
* 트랜잭션 정의
  * 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수해되어야 할 일련의 연산들을 의미 
  * 데이터베이스 시스템에서 병향 제어 및 회복 작업 시 처리되는 작어의 논리적 단위로 사용
  * 사용자가 시스템에 대한 서비스 요구 시 시스템이 응답하기 위한 상태 변환 과정의 작업 단위로 사용 

* 트랜잭션의 특성 
  * 무결성을 보장하기 위하여 DBMS의 트랜잭션이 가져야 할 특성
  * Atomicity(원자성) 
    * 트랜잭션의 연산은 완료(Commit)되든지 아니면 전혀 반영되지 않도록 복구(Rollback)되어야 함 
    * 트랜잭션 내의 모든 명령은 반드시 완벽히 수행되어야 함. 오류 발생시 트랜잭션 전부가 취소되어야 함
  * Consistency(일관성)
    * 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 전환
  * Isolation(독립성, 격리성, 순차성)
    * 둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행 중에 다른 트랜잭션의 연산이 끼어 들 수 없음 
    * 수행중인 트랜잭션은 완전히 완료될 때까지 다른 트랜잭션에서 수행결과를 참조할 수 없음
  * Durability(영속성, 지속성)
    * 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 함

* CRUD 분석 
  * 생성, 읽기, 갱신, 삭제의 앞 글자만 모아서 만든 용어. 데이터베이스 테이블에 변화를 주는 트랜잭션의 CRUD 연산에 대해 CRUD 매트릭스를 작성하여 분석 
  * 테이블에 발생되는 트랜잭션의 주기별 발생 횟수를 파악하고 연관된 테이블들을 분석하면 테이블에 저장되는 데이터의 양을 유추할 수 있음
  * 많은 트랜잭션이 몰리는 테이블을 파악할 수 있으므로 디스크 구성 시 유용한 자료로 활용 
  * 외부 프로세스 트랜잭션의 부하가 집중되는 데이터베이스 채널을 파악하고 분산시킴으로써 연결 지연이나 타임아웃 오류를 방지할 수 있음 

* CRUD 매트릭스 
  * 2차원 형태의 표. 행(Row)에는 프로세스를, 열(Column)에는 테이블을, 행과 열이 만나는 위치에는 ㅍ로세스가 테이블에 발생시키는 변화를 표시하는 업무 프로세스와 데이터 간 상관 분석표
  * 프로세스의 트랜잭션이 테이블에 수행하는 작업을 검증 
  * 각 셀에는 C, R, U, D가 들어감

* 트랜잭션 분석
  * 목적 : CRUD 매트릭스를 기반으로 테이블에 발생하는 트랜잭션 양을 분석하여 테이블에 저장되는 데이터의 양을 유추하고 이를 근거로 DB 용량을 산정하고 DB구조를 최적화하는 것
  * 트랜잭션 분석을 통해 프로세스가 과도하게 접근한느 테이블을 화긴하여 여러 디스크에 배치함으로써 디스크 입, 출력 분산을 통한 성능 향상을 가져올 수 있음 

* 트랜잭션 분석서 
  * 단위 프로세스와 CRUD 매트릭스를 이용하여 작성하며, 구성 요소에는 단위 프로세스, CRUD 연산, 테이블명 컬럼명, 테이블 참조 횟수, 트랜잭션 수, 발생 주기 등이 있음

<br> 

#### SECTION 088 인덱스 설계
* 인덱스의 개념 
  * 데이터 레코드를 빠르게 접근하기 위해 <키 값, 포인터> 쌍으로 구성되는 데이터 구조 
  * 레코드의 삽입과 삭제가 수시로 일어나는 경우에는 인덱스의 개수를 최소로 하는 것이 효율적 
  * 인덱스가 없으면 특정한 값을 찾기 위해 모든 데이터 페이지를 확인하는 TABLE SCAN(테이블에 있는 모든 레코드를 순차적으로 읽는 것)이 발생
  * 기본키를 위한 인덱스를 기본 인덱스. 기본 인덱스가 아닌 인덱스들을 보조 인덱스. 대부분의 관계형 데이터베이스 관리 시스템엣허는 모든 기본키에 대해서 자동적으로 기본 인덱스를 생성 
  * 레코드의 물리적 순서가 인덱스의 엔트리 순서와 일치하게 유지되도록 구성되는 인덱스를 클러스터드 인덱스
  * 트리 기반, 비트맵, 함수 기반, 비트맵 조인, 도메인 인덱스 등이 있음

* 트리 기반 인덱스 
  * 인덱스를 저장한느 블록들이 트리 구조를 이루고 있는 것. 상용 DBMS에서는 트리 구조 기반의 B+ 트리 인덱스를 주로 활용 
  * B 트리 인덱스 
    * 루트 노드에서 하위 노드로 키 값의크기를 비교해 나가면서 단말 노드에서 찾고자 하느 데이터를 검색 
    * 키 값과 레코드를 가리키는 포인터들이 트리 노드에 오름차순으로 저장 
    * 모든 리프 노드는 같은 레벨에 있음
  * B+ 트리 인덱스 
    * B 트리의 변형으로 단말 노드가 아닌 노드로 구성된 인덱스 세트와 단말 노드로만 구성된 순차 세트로 구분 
    * 인덱스 세트에 있는 노드들은 단말 노드에 있는 키 값을 찾아갈 수 있는 경로로만 제공되며, 순차 세트에 있는 단말 노드가 해당 데이터 레코드의 주소를 가리킴
    * 인덱스 세트에 있는 모든 키 값이 단말 노드에 다시 나타나므로 단말 노드만을 이용한 순차 처리가 가능 

* 비트맵 인덱스 
  * 인덱스 컬럼의 데이터를 Bit 값인 0 또는 1로 변환하여 인덱스 키로 사용하는 방법
  * 비트맵 인덱스의 목적은 키 값을 포함하는 로우의 주소를 제공하는 것
  * 비트맵 인덱스는 분포도가 좋은 컬럼에 적합하며, 성능 향상 효과를 얻을 수 있음
  * 데이터가 Bit로 구성되어 있기 때문에 효율적인 논리 연산이 가능하고 저장 공간이 작음 
  * 다중 조건을 만족하는 튜플의 개수 계산에 적합 
  * 동일한 값이 반복되는 경우가 많아 압축 효율이 좋음

* 함수 기반 인덱스
  * 컬럼의 값 대신 컬럼에 특정 함수나 수식을 적용하여 산출된 값을 사용하는 것으로, B+ 트리 인덱스 또는 비트맵 인덱스를 생성하여 사용함
  * 데이터르 입력하거나 순정할 때 함수를 적용해야 하므로 부하가 발생할 수 있음 
  * 사용자 정의 함수를 사용할 경우 시스템 함수보다 부하가 더 큼
  * 대소문자, 띄어쓰기 등에 상관없이 조회할 때 유용하게 사용됨 
  * 적용 가능한 함수 
    * 산술식(Arithmetic Expression), 사용자 정의 함수, PL/SQL Function, SQL Function, Package, C callout 등 

* 비트맵 조인 인덱스 
  * 다수의 조인된 객체로 구성된 인덱스로, 단일 객체로 구성된 일반적인 인덱스와 액세스 방법이 다름 
  * 비트맵 인덱스와 물리적 구조가 동일

* 도메인 인덱스 
  * 개발자가 필요한 인덱스를 직접 만들어 사용하는 것. 확장형 인덱스(Extensible Index)

* 인덱스 설계 
  * 분명하게 드러난칼럼에 대해 기본적인 인덱스를 먼저 저장한 후 개발 단계에서 필요한 인덱스의 설계를 반복적으로 진행 
  * 순서 
    * 대상 테이블, 컬럼 등을 선정 
    * 효율성을 검토하여 인덱스 최적화를 수행
    * 정의서를 작성 

* 인덱스 대상 테이블 선정 기준 
  * MULTI BLOCK READ(테이블 액세스 시 메모리에 한 번에 읽어 들일 수 있는 블록의 수) 수에 따라 판단
  * 랜덤 액세스가 빈번한 테이블
  * 특정 범위나 특정 순서로 데이터 조회가 필요한 테이블 
  * 다른 테이블과 순차적 조인이 발생되는 테이블

* 인덱스 대상 컬럼 선정 기준 
  * 인덱스 컬럼의 분포도가 10~15% 이내인 컬럼
    * 분포도 = ( 컬럼값의 평균 Row 수 / 테이블의 총 Row 수) x 100
  * 분포도가 10~15% 이상이어도 부분 처리를 목적으로 하는 컬럼 
  * 입, 출력 장표 등에서 조회 및 추력 조건으로 사용되는 컬럼 
  * 인덱스가 자동 생성되는 기본키와 Unique키 제약 조건을 사용한 컬럼 
  * 가능한 한 수정이 빈번하지 않은 컬럼
  * ORDER BY, GROUP BY, UNION이 빈번한 컬럼
  * 분포도가 좁은 컬럼은 단독 인덱스로 생성
  * 인덱스들이 자주 조합되어 사용되는 경우 하나의 결합 인덱스(Concatenate Index)로 생성

* 인덱스 설계 시 고려사항
  * 새로 추가되는 인덱스는 기본 액세스 경로에 영향을 미칠 수 있음
  * 인덱스를 지나치게 많이 만들면 오버헤드 발생
  * 넓은 범위를 인덱스로 처리하면 많은 오버헤드가 발생
  * 

  


